'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _escapeText = require('./escapeText');

var _escapeText2 = _interopRequireDefault(_escapeText);

var _styleToCSS = require('../style/styleToCSS');

var _styleToCSS2 = _interopRequireDefault(_styleToCSS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var OMITTED_CLOSE_TAGS = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttribute(prop, value) {
  return prop + '="' + (0, _escapeText2.default)(value) + '"';
}

function createOpenTagMarkup(tagName, style, attributes) {
  var tagOpen = '<' + tagName;

  if (style) {
    var styleAttr = (0, _styleToCSS2.default)(style, true);
    if (styleAttr) {
      tagOpen += ' ' + quoteAttribute('style', styleAttr);
    }
  }

  if (attributes) {
    for (var attrKey in attributes) {
      tagOpen += ' ' + quoteAttribute(attrKey, attributes[attrKey]);
    }
  }

  return tagOpen;
}

var Serializer = function () {
  function Serializer(node) {
    _classCallCheck(this, Serializer);

    this.html = '';
    this.startNode = node;
  }

  _createClass(Serializer, [{
    key: 'toJSON',
    value: function toJSON() {
      return this.toJSONChildren(this.startNode, true);
    }
  }, {
    key: 'toJSONChildren',
    value: function toJSONChildren(parentNode, isTopLevel) {
      var childNodes = parentNode.childNodes;

      if (childNodes) {
        var children = [];

        for (var i = 0, len = childNodes.length; i < len; i++) {
          var node = childNodes[i];
          if (node.nodeType === ELEMENT_NODE) {
            var json = {
              tagName: node.tagName
            };

            var childrenJSON = this.toJSONChildren(node);
            if (childrenJSON) {
              json.children = childrenJSON;
            }

            if (Object.keys(node.style).length) {
              json.style = node.style;
            }

            if (Object.keys(node.attributes).length) {
              json.attributes = node.attributes;
            }

            if (Object.keys(node.eventListeners).length) {
              json.eventListeners = node.eventListeners;
            }

            children.push(json);
          } else if (node.nodeType === TEXT_NODE) {
            var text = node.data;
            if (typeof text === 'string') {
              text = (0, _escapeText2.default)(text);
            }
            children.push(text);
          }
        }

        // Do not wrap array when only child in top-level
        if (isTopLevel && children.length === 1) {
          return children[0];
        }

        return children.length === 0 ? null : children;
      }

      return null;
    }
  }, {
    key: 'serialize',
    value: function serialize() {
      this.serializeChildren(this.startNode);
      return this.html;
    }
  }, {
    key: 'serializeChildren',
    value: function serializeChildren(parentNode) {
      var childNodes = parentNode.childNodes;

      if (childNodes) {
        for (var i = 0, len = childNodes.length; i < len; i++) {
          var node = childNodes[i];
          if (node.nodeType === ELEMENT_NODE) {
            var tagName = node.tagName.toLowerCase();

            this.html += createOpenTagMarkup(tagName, node.style, node.attributes);

            if (OMITTED_CLOSE_TAGS[tagName]) {
              this.html += '/>';
            } else {
              this.html += '>';
              if (node.__html) {
                this.html += node.__html;
              } else {
                this.serializeChildren(node);
              }
              this.html += '</' + tagName + '>';
            }
          } else if (node.nodeType === TEXT_NODE) {
            this.html += (0, _escapeText2.default)(node.data);
          } else if (node.nodeType === COMMENT_NODE) {
            this.html += '<!--' + node.data + '-->';
          }
        }
      }
    }
  }]);

  return Serializer;
}();

exports.default = Serializer;