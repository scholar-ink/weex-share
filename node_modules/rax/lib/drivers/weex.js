'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Weex driver
                                                                                                                                                                                                                                                                               **/


var _host = require('../vdom/host');

var _host2 = _interopRequireDefault(_host);

var _setNativeProps = require('../setNativeProps');

var _setNativeProps2 = _interopRequireDefault(_setNativeProps);

var _unit = require('../style/unit');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var STYLE = 'style';
var ID = 'id';
var TEXT = 'text';
var FULL_WIDTH_REM = 750;
var DOCUMENT_FRAGMENT_NODE = 11;
var nodeMaps = {};
/* global __weex_document__ */
var document = (typeof __weex_document__ === 'undefined' ? 'undefined' : _typeof(__weex_document__)) === 'object' ? __weex_document__ : (typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object' ? document : null;

var Driver = {
  getElementById: function getElementById(id) {
    return nodeMaps[id];
  },
  createBody: function createBody() {
    // Close batched updates
    document.open();

    if (document.body) {
      return document.body;
    }

    var documentElement = document.documentElement;
    var body = document.createBody();
    documentElement.appendChild(body);

    return body;
  },
  createFragment: function createFragment() {
    return {
      nodeType: DOCUMENT_FRAGMENT_NODE,
      childNodes: []
    };
  },
  createComment: function createComment(content) {
    return document.createComment(content);
  },
  createEmpty: function createEmpty() {
    return this.createComment(' empty ');
  },
  createText: function createText(text) {
    return Driver.createElement({
      type: TEXT,
      props: {
        value: text
      }
    });
  },
  updateText: function updateText(node, content) {
    this.setAttribute(node, 'value', content);
  },
  createElement: function createElement(component) {
    var props = component.props;
    var events = [];
    var style = {};
    var originStyle = props[STYLE];
    for (var prop in originStyle) {
      style[prop] = (0, _unit.convertUnit)(originStyle[prop], prop);
    }

    var node = document.createElement(component.type, {
      style: style
    });

    (0, _setNativeProps2.default)(node, props, true);

    return node;
  },
  appendChild: function appendChild(node, parent) {
    var _this = this;

    if (parent.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return parent.childNodes.push(node);
    } else if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return node.childNodes.map(function (child) {
        return _this.appendChild(child, parent);
      });
    } else {
      return parent.appendChild(node);
    }
  },
  removeChild: function removeChild(node, parent) {
    var id = node.attr && node.attr[ID];
    if (id != null) {
      nodeMaps[id] = null;
    }
    return parent.removeChild(node);
  },
  replaceChild: function replaceChild(newChild, oldChild, parent) {
    var previousSibling = oldChild.previousSibling;
    var nextSibling = oldChild.nextSibling;
    this.removeChild(oldChild, parent);

    if (previousSibling) {
      this.insertAfter(newChild, previousSibling, parent);
    } else if (nextSibling) {
      this.insertBefore(newChild, nextSibling, parent);
    } else {
      this.appendChild(newChild, parent);
    }
  },
  insertAfter: function insertAfter(node, after, parent) {
    var _this2 = this;

    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return node.childNodes.map(function (child, index) {
        return _this2.insertAfter(child, node.childNodes[index - 1] || after, parent);
      });
    } else {
      return parent.insertAfter(node, after);
    }
  },
  insertBefore: function insertBefore(node, before, parent) {
    var _this3 = this;

    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return node.childNodes.map(function (child, index) {
        return _this3.insertBefore(child, before, parent);
      });
    } else {
      return parent.insertBefore(node, before);
    }
  },
  addEventListener: function addEventListener(node, eventName, eventHandler) {
    return node.addEvent(eventName, eventHandler);
  },
  removeEventListener: function removeEventListener(node, eventName, eventHandler) {
    return node.removeEvent(eventName, eventHandler);
  },
  removeAllEventListeners: function removeAllEventListeners(node) {
    // noop
  },
  removeAttribute: function removeAttribute(node, propKey, propValue) {
    if (propKey == ID) {
      nodeMaps[propValue] = null;
    }
    // Weex native will crash when pass null value
    return node.setAttr(propKey, undefined);
  },
  setAttribute: function setAttribute(node, propKey, propValue) {
    if (propKey == ID) {
      nodeMaps[propValue] = node;
    }

    return node.setAttr(propKey, propValue);
  },
  setStyles: function setStyles(node, styles) {
    // TODO if more then one style update, call setStyles will be better performance
    for (var key in styles) {
      var val = styles[key];
      val = (0, _unit.convertUnit)(val, key);
      node.setStyle(key, val);
    }
  },
  beforeRender: function beforeRender() {
    // Init rem unit
    (0, _unit.setRem)(this.getWindowWidth() / FULL_WIDTH_REM);
  },
  afterRender: function afterRender() {
    if (document && document.listener && document.listener.createFinish) {
      document.listener.createFinish(function () {
        // Make updates batched
        document.close();
      });
    }
  },
  getWindowWidth: function getWindowWidth() {
    return FULL_WIDTH_REM;
  }
};

exports.default = Driver;