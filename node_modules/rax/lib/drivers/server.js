'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setNativeProps = require('../setNativeProps');

var _setNativeProps2 = _interopRequireDefault(_setNativeProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ID = 'id'; /**
                *  Server driver
                **/

var STYLE = 'style';
var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_FRAGMENT_NODE = 11;

var Driver = {
  // Internal state
  nodeMaps: {},
  nodeCounter: 0,

  getElementById: function getElementById(id) {
    return this.nodeMaps[id];
  },
  createBody: function createBody() {
    return {
      nodeType: ELEMENT_NODE,
      tagName: 'BODY',
      attributes: {},
      style: {},
      eventListeners: {},
      childNodes: [],
      parentNode: null
    };
  },
  createFragment: function createFragment() {
    return {
      nodeType: DOCUMENT_FRAGMENT_NODE,
      childNodes: []
    };
  },
  createComment: function createComment(content) {
    return {
      nodeType: COMMENT_NODE,
      data: content,
      parentNode: null,
      nodeId: this.nodeCounter++
    };
  },
  createEmpty: function createEmpty() {
    return this.createComment(' empty ');
  },
  createText: function createText(text) {
    return {
      nodeType: TEXT_NODE,
      data: text,
      parentNode: null,
      nodeId: this.nodeCounter++
    };
  },
  updateText: function updateText(node, text) {
    node.data = text;
  },
  createElement: function createElement(component) {
    var props = component.props;
    var node = {
      nodeType: ELEMENT_NODE,
      tagName: component.type.toUpperCase(),
      attributes: {},
      style: props.style || {},
      eventListeners: {},
      childNodes: [],
      parentNode: null,
      nodeId: this.nodeCounter++
    };

    (0, _setNativeProps2.default)(node, props, true);

    return node;
  },
  appendChild: function appendChild(node, parent) {
    var _this = this;

    if (parent.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return parent.childNodes.push(node);
    } else if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return node.childNodes.map(function (child) {
        return _this.appendChild(child, parent);
      });
    } else {
      parent.childNodes.push(node);
      node.parentNode = parent;
    }
  },
  removeChild: function removeChild(node, parent) {
    var id = node.attributes && node.attributes[ID];
    if (id != null) {
      this.nodeMaps[id] = null;
    }
    if (node.parentNode) {
      var idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  replaceChild: function replaceChild(newChild, oldChild, parent) {
    var previousSibling = this.previousSibling(oldChild);
    var nextSibling = this.nextSibling(oldChild);

    this.removeChild(oldChild, parent);
    if (previousSibling) {
      this.insertAfter(newChild, previousSibling, parent);
    } else if (nextSibling) {
      this.insertBefore(newChild, nextSibling, parent);
    } else {
      this.appendChild(newChild, parent);
    }
  },
  insertAfter: function insertAfter(node, after, parent) {
    var _this2 = this;

    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return node.childNodes.map(function (child, index) {
        return _this2.insertAfter(child, node.childNodes[index - 1] || after, parent);
      });
    } else {
      var nodeIdx = parent.childNodes.indexOf(node);
      if (nodeIdx !== -1) {
        parent.childNodes.splice(nodeIdx, 1);
      }

      var idx = parent.childNodes.indexOf(after);

      if (idx === parent.childNodes.length - 1) {
        parent.childNodes.push(node);
      } else {
        parent.childNodes.splice(idx + 1, 0, node);
      }
      node.parentNode = parent;
    }
  },
  insertBefore: function insertBefore(node, before, parent) {
    var _this3 = this;

    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return node.childNodes.map(function (child, index) {
        return _this3.insertBefore(child, before, parent);
      });
    } else {
      var nodeIdx = parent.childNodes.indexOf(node);
      if (nodeIdx !== -1) {
        parent.childNodes.splice(nodeIdx, 1);
      }

      var idx = parent.childNodes.indexOf(before);
      parent.childNodes.splice(idx, 0, node);
      node.parentNode = parent;
    }
  },
  nextSibling: function nextSibling(node) {
    var parentNode = node.parentNode;
    if (parentNode) {
      var idx = parentNode.childNodes.indexOf(node);
      return parentNode.childNodes[idx + 1];
    }
  },
  previousSibling: function previousSibling(node) {
    var parentNode = node.parentNode;
    if (parentNode) {
      var idx = parentNode.childNodes.indexOf(node);
      return parentNode.childNodes[idx - 1];
    }
  },
  addEventListener: function addEventListener(node, eventName, eventHandler) {
    node.eventListeners[eventName] = eventHandler;
  },
  removeEventListener: function removeEventListener(node, eventName, eventHandler) {
    delete node.eventListeners[eventName];
  },
  removeAllEventListeners: function removeAllEventListeners(node) {
    node.eventListeners = {};
  },
  removeAttribute: function removeAttribute(node, propKey, propValue) {
    if (propKey === 'className') {
      propKey = 'class';
    }

    if (propKey == ID) {
      this.nodeMaps[propValue] = null;
    }

    if (node.tagName === 'INPUT' && (propKey == 'checked' && (node.attributes.type === 'checkbox' || node.attributes.type === 'radio') || propKey == 'value')) {
      node.attributes[propKey] = null;
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      node.__html = null;
    } else {
      node.attributes[propKey] = null;
    }
  },
  setAttribute: function setAttribute(node, propKey, propValue) {
    if (propKey === 'className') {
      propKey = 'class';
    }

    if (propKey == ID) {
      this.nodeMaps[propValue] = node;
    }

    if (node.tagName === 'INPUT' && (propKey == 'checked' && (node.attributes.type === 'checkbox' || node.attributes.type === 'radio') || propKey == 'value')) {
      node.attributes[propKey] = propValue;
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      node.__html = propValue.__html;
    } else if (propValue != null) {
      node.attributes[propKey] = propValue;
    }
  },
  setStyles: function setStyles(node, styles) {
    for (var key in styles) {
      node.style[key] = styles[key];
    }
  }
};

exports.default = Driver;